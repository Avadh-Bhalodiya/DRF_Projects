# Serialization 

    - Complex Datatype -> Python Native Datatype -> Json data
    - get info. from database ->  convert in Python type -> then   last convert Json data
    - model -> Serialization -> Json

# DeSerialization 

    - Json data -> Python Native Datatype -> Complex Datatype
    - get Json data  ->  convert in Python type -> post data in    database
    - Json -> DeSerialization -> model

- jsond data -> stream using io.BytesIO -> python_data using
- JSONParser -> python_data convert Complex_data using serialization

Insert Data

# Validation

    priority Level:-
    1. Validators
    2. Field Level Validation
    3. Object Level Validation

# Model_Serializer

    - 1. name = serializers.CharField(read_only = True)
    - 2. read_only_field = ['name', 'roll']    // both mean are same
    - 3. extra_kwargs = {'name':{'read_only':True}}
    - this field only read not midified

    - Add Validation (Normally add)
     - check serializer.py (R4.../Validation)

# Function Based Api View
    - @api_view(['GET', 'POST', 'PUT', 'DELETE'])   //  multiple choice methods write, any function any method write just function above this line.

    - Response(serializer.data)     //  Response data convert json and send client side automatic

    - Student.objects.get(id=id)    // id = 1 check in Student model and compare id is in database? yes then continue

    - serializer = StudentSerialiazer(stu, many=True)   //  Miltiple data get form of queryset that's why many=True write

    - request.data      //      returns the parsed content of the request body
                        //      request.data # Handles arbitrary data. Works for 'POST', 'PUT' and 'PATCH' methods.
                        //      parsed content means get all data json form

    - save()    //  Data save
    - delete()  //  Data delete

    - PUT = complete update
    - PATCH = partial update    //      some kind of data update 